from langchain_core.tools import tool
from aimode.core.database import conn
from loguru import logger
from pydantic import BaseModel, Field
from typing import List, Optional
import requests
import json
from aimode.core.prompts import build_sql_generation_prompt, get_sql_table_names
from aimode.core.llms import llm



class SQLQueryGeneratorInput(BaseModel):
    user_query: str

@tool(args_schema=SQLQueryGeneratorInput)
def sql_query_generator(user_query)->str:
    """
    Generates an SQL query based on a natural language user query.
    
    This function uses a large language model to translate a user's natural language
    question into a valid SQL query that can be executed against the provided database
    connection.
    
    Args:
        user_query (str): Natural language query from the user
        
    Returns:
        str: Generated SQL query string ready for execution
    """
    try:
        logger.info(f'SQL Query Generated:\n{user_query}')
        # Get available tables
        available_tables = [table[0] for table in get_sql_table_names(conn)]
        
        # Generate the query
        sql_generation_prompt = build_sql_generation_prompt(conn=conn, user_query=user_query)
        
        # Use LangChain OpenAI
        response = llm.invoke(sql_generation_prompt)
        sql_query = response.content
        
        return sql_query
    except Exception as e:
        logger.error(e)
        return f"SELECT 'Error: {e}' as error;"



class SQLQueryExecutionInput(BaseModel):
    sql_query: str

@tool(args_schema=SQLQueryExecutionInput)
def execute_sql_query(sql_query)->list:
    """
    Executes an SQL query against the provided database connection.
    
    This function takes an SQL query string and executes it against the provided
    database connection, returning the results or handling any errors that occur.
    
    Args:
        sql_query (str): SQL query string to execute
        
    Returns:
        list: Query results as a list of rows if successful, or None if an error occurs
    """
    try:
        with conn.cursor() as cur:
            cur.execute(sql_query)
            results = cur.fetchall()
            conn.commit()
        logger.info('SQL Query Executed')
        return results
    except Exception as e:
        conn.rollback()
        logger.error(f"Error in executing the query: {e}")
        return None



def get_id_module_mapping():
    try:
        module_response = requests.get("https://sentri-qa-hea4embscubaejaw.eastasia-01.azurewebsites.net/api/module/")
        module_response.raise_for_status()  # Raise if not 2xx
        return module_response.json()
    except requests.HTTPError as e:
        logger.error(f"HTTP error fetching modules: {e} - Status: {module_response.status_code} - Text: {module_response.text}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"JSON decode error in module mapping: {e} - Text: {module_response.text}")
        return []
    except Exception as e:
        logger.error(f"Unexpected error fetching modules: {e}")
        return []


def get_ids_by_module_names(module_names: list[str]) -> list[int]:
    """Return list of IDs for given list of module names."""
    name_to_id = {m["name"]: m["id"] for m in get_id_module_mapping()  if isinstance(m, dict)}
    return [name_to_id.get(name) for name in module_names if name in name_to_id]



class TestPlanGeneratorInput(BaseModel):
    """Extracts parameters to generate test cases"""
    
    name: Optional[str] = Field(
        None, description="The name for the testcase (auto-generated by llm)"
    )
    description: Optional[str] = Field(
        None, description="The description of the testcase (auto-generated by llm)"
    )
    output_counts: Optional[int] = Field(
        None, description="Total number of test cases to generate"
    )
    module_names: Optional[List[str]] = Field(
        None, description="Extract ALL module names mentioned in the input as a complete list"
    )
    priority: Optional[str] = Field(
        None, description="Priority level: class_1, class_2, or class_3"
    )



@tool(args_schema=TestPlanGeneratorInput)
def generate_testplan(name:str, description:str, output_counts:int, module_names:list[str], priority:str):    
    """
    Generate a structured test plan based on extracted parameters.

    This tool generates test cases using the provided parameters without 
    requiring any database interaction. It is designed to work in 
    conjunction with LLM-based input extraction, where test plan 
    specifications are parsed into structured fields.

    Args:
        name (str): The auto-generated name of the test case.
        description (str): The auto-generated description of the test case.
        output_counts (int): The total number of test cases to generate.
        module_names (list[str]): A complete list of module names 
            mentioned in the input text.
        priority (str): The assigned priority level for the test cases. 
            Accepted values are: "class_1", "class_2", or "class_3".
    """


    tsp_params = {}
    tsp_params['name'] = name
    tsp_params['description'] = description
    tsp_params['output_counts'] = output_counts
    tsp_params['module_names'] = module_names
    tsp_params['priority'] = priority


    tsp_params["module_ids"] = get_ids_by_module_names(tsp_params['module_names'] or [])

    if tsp_params["output_counts"] and tsp_params["module_names"] and tsp_params["priority"]:

        url = "https://sentri-qa-hea4embscubaejaw.eastasia-01.azurewebsites.net/api/test-plan"
        payload = {
            "name": tsp_params['name'] or "Test Plan for Modules",
            "description": tsp_params['description'] or "This test plan focuses on ensuring the functionalities and integration tests",
            "output_counts": tsp_params['output_counts'],
            "module": tsp_params["module_ids"],
            "priority": tsp_params['priority']
        }

        logger.info(f"Payload: {payload}")

        headers = {"Content-Type": "application/json"}
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()  # Raise if not 2xx

        tcs_data = response.json()

        logger.info(f"Status Code: {response.status_code}")
        return tcs_data